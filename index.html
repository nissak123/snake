<!DOCTYPE html>

<html lang="ru">

<head>

    <meta charset="UTF-8">

    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>Doodle Jump Challenge</title>

    <script src="https://telegram.org/js/telegram-web-app.js"></script>

    <style>

        :root {

            --tg-bg: var(--tg-theme-bg-color, #ffffff);

            --tg-btn: var(--tg-theme-button-color, #2481cc);

            --tg-btn-text: var(--tg-theme-button-text-color, #ffffff);

        }

        body {

            font-family: 'Arial', sans-serif;

            background-color: #f0f0f0;

            margin: 0;

            display: flex;

            flex-direction: column;

            align-items: center;

            justify-content: center;

            height: 100vh;

            overflow: hidden;

            touch-action: none;

        }

        #gameContainer {

            position: relative;

            width: 320px;

            height: 500px;

            background-color: #ffffff;

            border: 2px solid #ddd;

            overflow: hidden;

            box-shadow: 0 10px 30px rgba(0,0,0,0.1);

        }

        #score {

            position: absolute;

            top: 15px; left: 15px;

            font-size: 26px; font-weight: 900; color: #333;

            z-index: 5;

        }

        #startScreen {

            position: absolute;

            inset: 0;

            background: rgba(255,255,255,0.8);

            display: flex;

            align-items: center;

            justify-content: center;

            z-index: 10;

        }

        #start-button {

            padding: 18px 35px;

            background: var(--tg-btn);

            color: var(--tg-btn-text);

            border: none;

            border-radius: 15px;

            font-size: 20px;

            font-weight: bold;

        }

        #controls {

            display: flex;

            gap: 60px;

            margin-top: 25px;

        }

        .btn {

            width: 75px; height: 75px;

            background: var(--tg-btn);

            border-radius: 50%;

            border: none;

            color: white;

            font-size: 30px;

            box-shadow: 0 4px 10px rgba(0,0,0,0.2);

            user-select: none;

            -webkit-user-select: none;

        }

    </style>

</head>

<body>



    <div id="gameContainer">

        <div id="score">0</div>

        <canvas id="gameCanvas" width="320" height="500"></canvas>

        <div id="startScreen">

            <button id="start-button">ПОГНАЛИ!</button>

        </div>

    </div>



    <div id="controls">

        <button id="left-btn" class="btn">◀</button>

        <button id="right-btn" class="btn">▶</button>

    </div>



    <script>

        const tg = window.Telegram.WebApp;

        tg.ready();

        tg.expand();



        const canvas = document.getElementById('gameCanvas');

        const ctx = canvas.getContext('2d');

        const scoreDiv = document.getElementById('score');

        const startScreen = document.getElementById('startScreen');



        const playerImg = new Image();

        playerImg.src = 'player.png?v=' + Date.now(); 



        let player = { x: 135, y: 300, w: 50, h: 50, dx: 0, dy: 0 };

        let platforms = [];

        let particles = [];

        let score = 0;

        let gameOver = true;

        let gameInterval;

        

        const BASE_PLATFORM_WIDTH = 70;

        let currentPlatformWidth = BASE_PLATFORM_WIDTH;

        let lastDifficultyTier = 0;

        

        // Отслеживание состояния кнопок

        let leftPressed = false;

        let rightPressed = false;

        let lastPressed = null;

        let activeTouches = new Map();



        function createPlatforms() {

            platforms = [];

            currentPlatformWidth = BASE_PLATFORM_WIDTH;

            lastDifficultyTier = 0;

            platforms.push({ x: 110, y: 420, w: 100, h: 15, mv: 0, breakable: false, used: false });

            for(let i = 1; i < 7; i++) {

                addPlatform(420 - (i * 80));

            }

        }



        function addPlatform(yPos) {

            const isMoving = Math.random() > 0.6;

            const isBreakable = Math.random() > 0.7;

            platforms.push({

                x: Math.random() * (320 - currentPlatformWidth),

                y: yPos,

                w: currentPlatformWidth,

                h: 12,

                mv: isMoving ? (Math.random() - 0.5) * 4 : 0,

                breakable: isBreakable,

                used: false

            });

        }



        function createGoldParticles(x, y) {

            for (let i = 0; i < 8; i++) {

                particles.push({

                    x: x + player.w / 2,

                    y: y + player.h,

                    vx: (Math.random() - 0.5) * 4,

                    vy: Math.random() * -3 - 1,

                    life: 40,

                    size: 4 + Math.random() * 3,

                    color: "#FFD700"

                });

            }

        }



        function createBreakParticles(p) {

            for (let i = 0; i < 12; i++) {

                particles.push({

                    x: p.x + p.w / 2,

                    y: p.y + p.h / 2,

                    vx: (Math.random() - 0.5) * 6,

                    vy: (Math.random() - 0.5) * 6,

                    life: 30,

                    size: 3 + Math.random() * 2,

                    color: "#8B4513"

                });

            }

        }



        function drawRoundedRect(x, y, w, h, radius) {

            ctx.beginPath();

            ctx.moveTo(x + radius, y);

            ctx.lineTo(x + w - radius, y);

            ctx.arcTo(x + w, y, x + w, y + radius, radius);

            ctx.lineTo(x + w, y + h - radius);

            ctx.arcTo(x + w, y + h, x + w - radius, y + h, radius);

            ctx.lineTo(x + radius, y + h);

            ctx.arcTo(x, y + h, x, y + h - radius, radius);

            ctx.lineTo(x, y + radius);

            ctx.arcTo(x, y, x + radius, y, radius);

            ctx.closePath();

            ctx.fill();

        }



        function updatePlayerDirection() {

            // Если обе кнопки зажаты, приоритет у последней нажатой

            if (leftPressed && rightPressed) {

                if (lastPressed === 'left') {

                    player.dx = -5;

                } else {

                    player.dx = 5;

                }

            } else if (leftPressed) {

                player.dx = -5;

            } else if (rightPressed) {

                player.dx = 5;

            } else {

                player.dx = 0;

            }

        }



        function init() {

            player.x = 135; player.y = 300; player.dy = 0; player.dx = 0;

            score = 0;

            scoreDiv.textContent = '0';

            particles = [];

            leftPressed = false;

            rightPressed = false;

            lastPressed = null;

            activeTouches.clear();

            createPlatforms();

            startScreen.style.display = 'none';

            gameOver = false;

            if(gameInterval) clearInterval(gameInterval);

            gameInterval = setInterval(update, 1000/60);

        }



        function update() {

            if(gameOver) return;



            player.dy += 0.28;

            player.y += player.dy;

            player.x += player.dx;



            if (player.x < -40) player.x = 320;

            if (player.x > 320) player.x = -40;



            let difficultyTier = Math.floor(score / 1000);

            if (difficultyTier > lastDifficultyTier) {

                currentPlatformWidth *= 0.9;

                lastDifficultyTier = difficultyTier;

                platforms.forEach(p => {

                    p.w = currentPlatformWidth;

                });

                tg.HapticFeedback.notificationOccurred('success');

            }



            platforms = platforms.filter(p => !p.toRemove);



            platforms.forEach(p => {

                if (p.mv !== 0) {

                    p.x += p.mv;

                    if (p.x < -p.w) p.x = 320;

                    if (p.x > 320) p.x = -p.w;

                }



                if (player.dy > 0 && player.x + 10 < p.x + p.w && player.x + player.w - 10 > p.x &&

                    player.y + player.h > p.y && player.y + player.h < p.y + p.h + 12) {

                    

                    if (p.breakable && p.used) {

                        createBreakParticles(p);

                        p.toRemove = true;

                        tg.HapticFeedback.impactOccurred('heavy');

                    } else {

                        player.dy = -10;

                        score += 20; 

                        tg.HapticFeedback.impactOccurred('medium');

                        createGoldParticles(player.x, player.y);

                        

                        if (p.breakable) {

                            p.used = true;

                        }

                    }

                }

            });



            if (player.y < 200) {

                let offset = 200 - player.y;

                player.y = 200;

                score += Math.floor(offset); 

                scoreDiv.textContent = score;

                platforms.forEach(p => {

                    p.y += offset;

                    if (p.y > 500) {

                        p.y = -20;

                        p.x = Math.random() * (320 - currentPlatformWidth);

                        p.mv = Math.random() > 0.5 ? (Math.random() - 0.5) * (4 + difficultyTier) : 0;

                        p.breakable = Math.random() > 0.7;

                        p.used = false;

                        p.toRemove = false;

                    }

                });

                particles.forEach(part => part.y += offset);

            }



            if (player.y > 500) {

                gameOver = true;

                clearInterval(gameInterval);

                tg.HapticFeedback.notificationOccurred('error');

                alert("Game Over! Твой рекорд: " + score);

                startScreen.style.display = 'flex';

            }



            for (let i = particles.length - 1; i >= 0; i--) {

                let part = particles[i];

                part.x += part.vx; part.y += part.vy;

                part.vy += 0.15; part.life--;

                if (part.life <= 0) particles.splice(i, 1);

            }



            draw();

        }



        function draw() {

            ctx.clearRect(0, 0, 320, 500);

            

            platforms.forEach(p => {

                if (p.breakable) {

                    ctx.fillStyle = "#8B4513";

                } else if (p.mv !== 0) {

                    ctx.fillStyle = "#ff4444";

                } else {

                    ctx.fillStyle = "#2e7d32";

                }

                

                drawRoundedRect(p.x, p.y, p.w, p.h, 6);

            });



            particles.forEach(part => {

                ctx.globalAlpha = part.life / 40;

                ctx.fillStyle = part.color;

                ctx.beginPath();

                ctx.arc(part.x, part.y, part.size, 0, Math.PI*2);

                ctx.fill();

                ctx.globalAlpha = 1;

            });



            if (playerImg.complete && playerImg.naturalWidth > 0) {

                ctx.drawImage(playerImg, player.x, player.y, player.w, player.h);

            } else {

                ctx.fillStyle = "#ff8f00";

                ctx.fillRect(player.x, player.y, player.w, player.h);

            }

        }



        const L = document.getElementById('left-btn');

        const R = document.getElementById('right-btn');



        // Функции для установки состояния кнопок

        function setLeftButton(pressed) {

            leftPressed = pressed;

            if (pressed) {

                lastPressed = 'left';

            } else {

                // Если отпустили левую, а правая зажата - переключаем lastPressed

                if (rightPressed) {

                    lastPressed = 'right';

                } else {

                    lastPressed = null;

                }

            }

            updatePlayerDirection();

        }



        function setRightButton(pressed) {

            rightPressed = pressed;

            if (pressed) {

                lastPressed = 'right';

            } else {

                // Если отпустили правую, а левая зажата - переключаем lastPressed

                if (leftPressed) {

                    lastPressed = 'left';

                } else {

                    lastPressed = null;

                }

            }

            updatePlayerDirection();

        }



        // Обработка касаний для левой кнопки

        L.addEventListener('touchstart', (e) => { 

            e.preventDefault();

            for (let touch of e.changedTouches) {

                activeTouches.set(touch.identifier, 'left');

            }

            setLeftButton(true);

        }, { passive: false });



        L.addEventListener('touchend', (e) => { 

            e.preventDefault();

            for (let touch of e.changedTouches) {

                activeTouches.delete(touch.identifier);

            }

            let hasLeftTouch = Array.from(activeTouches.values()).includes('left');

            setLeftButton(hasLeftTouch);

        }, { passive: false });



        L.addEventListener('touchcancel', (e) => { 

            e.preventDefault();

            for (let touch of e.changedTouches) {

                activeTouches.delete(touch.identifier);

            }

            let hasLeftTouch = Array.from(activeTouches.values()).includes('left');

            setLeftButton(hasLeftTouch);

        }, { passive: false });



        // Обработка касаний для правой кнопки

        R.addEventListener('touchstart', (e) => { 

            e.preventDefault();

            for (let touch of e.changedTouches) {

                activeTouches.set(touch.identifier, 'right');

            }

            setRightButton(true);

        }, { passive: false });



        R.addEventListener('touchend', (e) => { 

            e.preventDefault();

            for (let touch of e.changedTouches) {

                activeTouches.delete(touch.identifier);

            }

            let hasRightTouch = Array.from(activeTouches.values()).includes('right');

            setRightButton(hasRightTouch);

        }, { passive: false });



        R.addEventListener('touchcancel', (e) => { 

            e.preventDefault();

            for (let touch of e.changedTouches) {

                activeTouches.delete(touch.identifier);

            }

            let hasRightTouch = Array.from(activeTouches.values()).includes('right');

            setRightButton(hasRightTouch);

        }, { passive: false });



        // Обработка мыши (для тестирования на ПК)

        L.addEventListener('mousedown', (e) => { 

            e.preventDefault(); 

            setLeftButton(true);

        });

        L.addEventListener('mouseup', (e) => { 

            e.preventDefault(); 

            setLeftButton(false);

        });

        L.addEventListener('mouseleave', (e) => { 

            setLeftButton(false);

        });



        R.addEventListener('mousedown', (e) => { 

            e.preventDefault(); 

            setRightButton(true);

        });

        R.addEventListener('mouseup', (e) => { 

            e.preventDefault(); 

            setRightButton(false);

        });

        R.addEventListener('mouseleave', (e) => { 

            setRightButton(false);

        });



        // Глобальный сброс при отпускании пальца вне кнопок

        document.addEventListener('touchend', (e) => {

            for (let touch of e.changedTouches) {

                activeTouches.delete(touch.identifier);

            }

        }, { passive: true });



        document.getElementById('start-button').onclick = init;

        draw();

    </script>

</body>

</html>
